#include "thread_pool.h"
/**
 * @brief Конструктор класса ThreadPool.
 *
 * @param threads Количество потоков в пуле.
 *
 * Конструктор инициализирует пул потоков с заданным количеством потоков.
 * В каждом потоке выполняется бесконечный цикл, в котором извлекается задача
 * из очереди `tasks` и выполняется с помощью указателя на функцию.
 *
 * Если пул остановлен (флаг `stop` установлен в `true`) и очередь задач `tasks` пуста,
 * поток завершает свою работу и выходит из цикла.
 */
ThreadPool::ThreadPool(size_t threads) : stop(false)
{
    for (size_t i = 0; i < threads; ++i)
    {
        workers.emplace_back([=](){
            for(;;){
                std::shared_ptr<std::function<void()>> task;
                {
                    std::unique_lock<std::mutex> lock(mtx);
                    cond.wait(lock,[=](){return !tasks.empty() || stop;});
                    if (stop && tasks.empty()) return;
                    task = std::move(tasks.front());
                    tasks.pop();
                }
                (*task)();
    }});}
}


/**
 * Деструктор класса ThreadPool.
 *
 * Останавливает выполнение всех потоков пула и освобождает ресурсы.
 *
 * Данный деструктор останавливает выполнение всех потоков пула. Сначала флаг `stop` устанавливается в значение `true` с помощью `std::unique_lock` и `std::mutex`. Это гарантирует, что никакие новые задачи не будут добавлены в очередь после этого момента.
 *
 * Затем вызывается `cond.notify_all()`, чтобы уведомить все потоки пула о необходимости завершить выполнение. Это позволяет потокам выйти из ожидания и проверить флаг `stop` для определения, нужно ли им завершить выполнение.
 *
 * После этого, в цикле происходит ожидание завершения всех потоков с помощью `thread.join()`. Это гарантирует, что все потоки будут завершены и ресурсы будут корректно освобождены.
 *
 * Таким образом, деструктор освобождает ресурсы и завершает работу пула потоков.
 */
ThreadPool::~ThreadPool()
{
    {
        std::unique_lock<std::mutex> lock(mtx);
        stop = true;
    }
    cond.notify_all();
    for(auto &thread : workers)
    {
        thread.join();
    }
}

